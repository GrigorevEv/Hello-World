# D-Компьютерная игра
# Герою компьютерной игры нужно перебраться от одного края экрана к другому, перепрыгивая по платформам.
# При этом при прыжке с одной платформы на соседнюю, у героя уходит |y2-y1| единиц энергии, где y1 и y2 – высоты,
# на которых расположены эти платформы.
# Кроме того, у героя есть суперприем, который позволяет перескочить через платформу,
# но на это затрачивается 3*|y3-y1| единиц энергии.
# Конечно же, энергию следует расходовать максимально экономно.
# Вам известны высоты всех платформ в порядке от левого края до правого.
# Необходимо найти, какое минимальное количество энергии потребуется герою,
# чтобы добраться с первой платформы до последней.
# Формат входных данных
# В первой строке - количество платформ (0 < n <= 30000).
# Далее на каждой из n строк записана высота , на которой расположена очередная платформа.
# Формат выходных данных
# Одно число — минимальное количество энергии, которую должен потратить герой на преодоление платформ.


def min_cost():
    n = int(input())
    a = []
    c = []
    for i in range(n):
        a.append(int(input()))
        c.append(0)  # Создаем массив со стоимостями. Его длинна будет равна длинне массива с платформами.
    if len(a) == 1:  # Если массив с платформами содержит всего одну платформу,
        print(0)     # то стоимость посещения последний платформы равна нулю. Прыгать никуда не надо.
    else:
        c[1] = abs(a[1] - a[0])  # Создаем стоимость посещения второй платформы
        for i in range(2, n):    # запускаем цикл, который расчитывает минимальную стоимость посещения каждый платформы
            c[i] = min(abs(a[i] - a[i-1]) + c[i-1], abs(3*(a[i]-a[i-2])) + c[i-2])
        print(c[-1])


min_cost()





