# Кузнечик-брокер
# Кузнечик находится на Бирже, которая является числовой прямой, в клетке №1 и собирается заработать денег.
# В каждой клетке числовой прямой, которую он посещает, он вынужден заключить сделку со всеми имеющимися средствами.
# При этом он может получить как прибыль, так и убыток. Прибыльность каждой клетки задана процентами со знаком.
# Если знак положительный — сделка увеличивает сумму денег Кузнечика на указанный процент от его текущей суммы.
# Если отрицательный — сделка уменьшает сумму денег Кузнечика на указанный процент.
# В самой клетке №1 никакой сделки не заключается.
# Вывести на экран путь, максимизирующий сумму, которую сможет заработать Кузнечик на бирже,
# если он может совершать прыжки на клетку с номером +2 и +3 от текущей, но не может прыгнуть на соседнюю клетку.
# Обратите внимание, что Кузнечик не обязан останавливаться в точке последней возможной сделки!
# Более того, если совершение сделок окажется убыточным, Кузнечик имеет право остаться в клетке №1 с исходным капиталом.
# Формат входных данных
# В первой строке записано целое число — стартовый капитал Кузнечика.
# Во второй строке записаны целые числа — проценты со знаком + или -.
# Доходность не превышает 1000%, а убыточность -100%. Отрицательный баланс у Кузнечика недопустим.
# Максимальный номер клетки задаётся количеством чисел в строке ввода.
# Формат выходных данных
# Клетки, по которым должен пройти Кузнечик, чтобы получить максимальную выгоду.

start_up_capital = float(input())
stock_exchange = list(map(float, input().split()))
path_len = len(stock_exchange)
dealings = [start_up_capital] + [0.] * (path_len - 1)
# Будем считать, что кузнечик не может прыгать на и с клетки dealings[1], только с клетки dealings[0]
# соответственно в клетку dealings[4] он может попасть только из клетки dealings[2]
for i in range(2, path_len):
    if i == 4 or i == 2:
        dealings[i] = stock_exchange[i]*start_up_capital/100 + dealings[i-2]
        continue
    dealings[i] = stock_exchange[i]*start_up_capital/100 + max(dealings[i-2], dealings[i-3])
if dealings[path_len-1] < dealings[path_len-2]:
    dealings.pop(path_len-1)
n = len(dealings) - 1
path = [len(dealings)]
while n > 0:
    if n == 4 or n == 2 or dealings[n-2] > dealings[n-3]:
        n -= 2
    else:
        n -= 3
    path.append(n+1)
if dealings[len(dealings)-2] < start_up_capital and dealings[len(dealings)-1] < start_up_capital:
    path.clear()
    path.append(1)
for i in range(len(path)-1, -1, -1):
    print(path[i], end=' ')
