# https://e-maxx.ru/algo/prefix_function
# Префикс-функция. Определение
# Дана строка s[0 ... n-1]. Требуется вычислить для неё префикс-функцию, т.е. массив чисел pi[0 ... n-1],
# где pi[i] определяется следующим образом: это такая наибольшая длина наибольшего собственного суффикса
# подстроки s[0 ... i] , совпадающего с её префиксом (собственный суффикс — значит не совпадающий со всей
# строкой). В частности, pi[0] значение полагается равным нулю.
# Например, для строки "abcabcd" префикс-функция равна: [0, 0, 0, 1, 2, 3, 0] , что означает:
# ● у строки "a" нет нетривиального префикса, совпадающего с суффиксом;
# ● у строки "ab" нет нетривиального префикса, совпадающего с суффиксом;
# ● у строки "abc" нет нетривиального префикса, совпадающего с суффиксом;
# ● у строки "abca" префикс длины 1 совпадает с суффиксом;
# ● у строки "abcab" префикс длины 2 совпадает с суффиксом;
# ● у строки "abcabc" префикс длины 3 совпадает с суффиксом;
# ● у строки "abcabcd" нет нетривиального префикса, совпадающего с суффиксом.
# Другой пример — для строки "aabaaab" она равна: [0, 1, 0, 1, 2, 2, 3] .
# Непосредственно следуя определению, можно написать такой алгоритм вычисления префикс-функции,
# как нетрудно заметить, работать он будет за O(n**3), что слишком медленно:


def p_func(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        for k in range(1, i + 1):
            equal = True
            for j in range(k):
                if s[j] != s[i - k + 1 + j]:
                    equal = False
                    break
            if equal:
                pi[i] = k
    return pi


print(p_func('aabaaab'))
