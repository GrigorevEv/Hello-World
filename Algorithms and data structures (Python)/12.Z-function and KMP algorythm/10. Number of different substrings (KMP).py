# https://e-maxx.ru/algo/prefix_function
# Количество различных подстрок в строке
# Дана строка s длины n. Требуется посчитать количество её различных подстрок.
# Будем решать эту задачу итеративно. А именно, научимся, зная текущее количество различных подстрок,
# пересчитывать это количество при добавлении в конец одного символа.
# Итак, пусть k — текущее количество различных подстрок строки s, и мы добавляем в конец символ c.
# Очевидно, в результате могли появиться некоторые новые подстроки, оканчивавшиеся на этом новом символе c.
# А именно, добавляются в качестве новых те подстроки, оканчивающиеся на символе c и не встречавшиеся ранее.
# Возьмём строку t = s + c и инвертируем её (запишем символы в обратном порядке).
# Наша задача — посчитать, сколько у строки t таких префиксов, которые не встречаются в ней более нигде.
# Но если мы посчитаем для строки t префикс-функцию и найдём её максимальное значение \pi_{\rm max}, то, очевидно,
# в строке t встречается (не в начале) её префикс длины \pi_{\rm max}, но не большей длины.
# Понятно, префиксы меньшей длины уж точно встречаются в ней.
# Итак, мы получили, что число новых подстрок, появляющихся при дописывании символа c,
# равно s.length() - max(pi).
# Таким образом, для каждого дописываемого символа мы за O(n) можем пересчитать количество различных подстрок строки.
# Следовательно, за O(n^2) мы можем найти количество различных подстрок для любой заданной строки.
# Стоит заметить, что совершенно аналогично можно пересчитывать количество различных подстрок и при
# дописывании символа в начало, а также при удалении символа с конца или с начала

def p_func(s):
    n = len(s)
    pi = [0] * n
    t = []
    k = 0
    for f in range(n):
        t += s[f]
        rt = t[::-1]
        for i in range(1, len(rt)):
            j = pi[i-1]
            while j > 0 and rt[i] != rt[j]:
                j = pi[j-1]
            if rt[i] == rt[j]:
                j += 1
                pi[i] = j
        k += len(rt) - max(pi)
    return k


print(p_func('abc'))
