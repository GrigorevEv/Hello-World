# https://e-maxx.ru/algo/prefix_function
# Сжатие строки
# Дана строка s длины n. Требуется найти самое короткое её "сжатое" представление, т.е.
# найти такую строку t наименьшей длины, что s можно представить в виде конкатенации одной или нескольких копий t.
# Понятно, что проблема является в нахождении длины искомой строки t.
# Зная длину, ответом на задачу будет, например, префикс строки s этой длины.
# Посчитаем по строке s префикс-функцию. Рассмотрим её последнее значение, т.е. pi[n-1], и введём обозначение
# k = n - pi[n-1]. Покажем, что если n делится на k, то это k и будет длиной ответа,
# иначе эффективного сжатия не существует, и ответ равен n.
# Действительно, пусть n делится на k. Тогда строку можно представить в виде нескольких блоков длины k,
# причём, по определению префикс-функции, префикс длины n-k будет совпадать с её суффиксом.
# Но тогда последний блок должен будет совпадать с предпоследним, предпоследний - с предпредпоследним,
# и т.д. В итоге получится, что все блоки блоки совпадают, и такое k действительно подходит под ответ.
# Покажем, что этот ответ оптимален. Действительно, в противном случае, если бы нашлось меньшее k,
# то и префикс-функция на конце была бы больше, чем n-k, т.е. пришли к противоречию.
# Пусть теперь n не делится на k. Покажем, что отсюда следует, что длина ответа равна n.
# Докажем от противного — предположим, что ответ существует, и имеет длину p (p делитель n).
# Заметим, что префикс-функция необходимо должна быть больше n - p, т.е. этот суффикс должен частично
# накрывать первый блок. Теперь рассмотрим второй блок строки; т.к. префикс совпадает с суффиксом,
# и префикс, и суффикс покрывают этот блок, и их смещение друг относительно друга k не делит длину блока p
# (а иначе бы k делило n), то все символы блока совпадают. Но тогда строка состоит из одного и того же символа,
# отсюда k=1, и ответ должен существовать, т.е. так мы придём к противоречию.

def p_func(s):
    global t
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i-1]
        while j > 0 and s[i] != s[j]:
            j = pi[j-1]
        if s[i] == s[j]:
            j += 1
            pi[i] = j
    print(pi)
    k = n - pi[n-1]
    if n % k == 0:
        t = s[0:k]
    return t


print(p_func('abababab'))
