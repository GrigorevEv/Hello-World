# Динамическое программирование — решение сложной задачи разбиением её на более простые подзадачи,
# при этом каждая подзадача решается только один раз.
# Динамическое программирование очень похоже на рекурсию, при этом:
# динамическое программирование сверху — это по сути рекурсия с кешированием;
# динамическое программирование снизу — это переформулирование задачи в виде индуктивной последовательности подзадач,
# от крайнего случая к более сложным.
# Математическая индукция — метод математического доказательства, который используется,
# чтобы доказать истинность некоторого утверждения для всех натуральных чисел.
# Для этого сначала проверяется истинность утверждения с номером 1 — база (базис) индукции,
# а затем доказывается, что если верно утверждение с номером n, то верно и следующее утверждение с номером
# n+1 — шаг индукции, или индукционный переход.
# Доказательство по индукции наглядно может быть представлено в виде так называемого принципа домино.
# Пусть какое угодно число косточек домино выставлено в ряд таким образом, что каждая косточка, падая,
# обязательно опрокидывает следующую за ней косточку (в этом заключается индукционный переход).
# Тогда, если мы толкнём первую косточку (это база индукции), то все косточки в ряду упадут.
# Одномерное динамическое программирование
# Классическая задача — числа Фибоначчи
# Последовательность Фибоначчи Fn задается формулами: F1 = 1, F2 = 1, Fn = Fn – 1 + Fn – 2 при n > 1.
# Необходимо найти Fn по номеру n.
# Один из способов решения, который может показаться логичным и эффективным, — решение с помощью рекурсии:
# def fib(n):
#     if n <= 1:
#         return n
#     else:
#         return fib(n-1) + fib(n-2)
# Используя такую функцию, мы будем решать задачу «с конца» — будем шаг за шагом уменьшать n,
# пока не дойдем до известных значений.
# Но как можно заметить, такая, казалось бы, простая программа уже при n = 40 работает заметно долго.
# Это связано с тем, что одни и те же промежуточные данные вычисляются по несколько раз — число операций
# нарастает с той же скоростью, с какой растут числа Фибоначчи — экспоненциально.
# Один из выходов из данной ситуации — сохранение уже найденных промежуточных результатов
# с целью их повторного использования (кеширование):
# F = [-1]*MAX_POSSIBLE_N
# def fib(n):
#     if n <= 1:
#         return n
#     if F[n] == -1:
#         F[n] = fib(n-1) + fib(n-2)
#     return F[n]
# Приведенное решение корректно и эффективно. Но можно поступить ещё проще:
# def fib(n):
#     F = [-1]*(n+1)
#     F[0] = 0
#     F[1] = 1
#     for i in range(2, n+1):
#         F[i] = F[i - 1] + F[i - 2]
#     return F[n]
# Такое решение можно назвать решением «с начала» — мы первым делом заполняем известные значения,
# затем находим первое неизвестное значение, потом следующее и т.д., пока не дойдем до нужного.
# Именно такое решение и является классическим для динамического программирования:
# мы сначала решили все подзадачи (нашли все F[i] для i < n), затем, зная решения подзадач, нашли ответ.
